'use strict'				цю стрічку (ДИРЕКТИВУ) ми пишемо в самому початку файла js. вона означає, шо ми пишемо на стандарті ES6.
<script> alert(1) </script>		можна підключити прямо в html 
<script src="script.js"></script>	або його можна підключити до окремого файла. Є файли локальні і віддалені
// "Hello world!" 			односторокоий коментарій. швидкі клавіші: "CTRL + /"
/* "Hello world! */			багатостроковий коментарій
var leftBorderWidth = 1;		позначання змінної. Змінна мусить починатися з букви і містити букви, цифри, знак долара і нижнього підкреслення.
					назви змінних не можуть бути такі, які вже являються командами в мові програмування (alert, error, promt....)
					!!! ЯКЩО VAR ОГОЛОШЕНО В КОДІ, ТО ВОНА ВЖЕ ІСНУЄ ДО ВИПОВНЕННЯ СКРІПТА І ЇЇ ВИДНО ВСЮДИ. АЛЕ ЇЇ ЗНАЧЕНННЯ БУДЕ ВИДНО
					ЛИШЕ ТОДІ, ЯКШО ПРИСВОЄННЯ ЗНАЧЕННЯ БУДЕ РАНІШЕ ЗА ДІЮ, КОМАНДУ СКРИПТА !!!
let second = 2;				таким чином задана змінна почне існувати тільки після даної команди. тип Let застосовують тільки тоді, коли код до 
					нього доходить. такий тип оголошення називають "Всплитія пєрємєнних" або "хостинг". таким методом оптимізується пришвидшується код
					і економить нашу память браузера. Крім того LET буде видимий лише в зоні, обумовленій фігурними дужками {}
 
const pi = 3.14;			створює константу, яку неможливо поміняти. А з усім іншим - аналогічно LET.
consol.log(leftBorderWidth);		команда, яка буде виводити значення змінної в консоль браузера
	
						^^^^ТИПИ ЗМІННИХ:^^^^^^^
1. число number  var number = 5;
	цілі, дробові, Infinity (отримуємо при діленні на 0), NoN (not a number) (при операції без мамематичної логіки - напр. помножити або розділити число на строку)
2. строка string   var string = "Hello!";
	записується на кавичках ""   ''    ``
3. символ sym   var sum = Symbol();
	поки не дали інфи. просто треба знати, що він існує
4. логічний boolean   var boolen = true;
	 або так True, або ні False
5. nuul  null;
	коли чогось в коді просто не існує. По суті - це ссилка на неіснуючу річ. коли в вікні від команди prompt натиснути отмєна, то вурнеться 
	цей тип даних
6. undefined   undefined;
	коли змінна існує в коді, але нічого їй не присвоєно ще.
7. обєкт Object   var obj = {};
	комплексний тип даних, колекція даних, структура, яка використовується для зберігання будь яких даних. Наприклад:
				let persone = {
   				name: "John",
   				age: "25",
 				isMarried: false
				};
	якшо ми хочемо звернутися до однієї зі мнінних цього обєкта, то на нам слід це робити таким способом:
				console.log(persone.name);
	є ще й інший варіант запису. він використовується рідше і призначенний для випадків, якщо змінній присвоєно довге строкове значення
				console.log(persone["name"]);
	так само квадратні дужки служать у випадку, коли нам треба звернутися до змінної, а не до значення змінної
7.1. масив arrey  let arr = ['plum.png','jrange.jpg', 'apple.bmp'];
	масив є різновидністю обєкта. масив використовується для зберігання будь яких типів данних, які йдуть попордядку. Масив обзмежується квадратними дужками і 
	построєний так,	що для кожного значення в ньогу автоматично присвоюється порядковий номер. Масив може зберігати в собі на стільки строки, але і числа, 
	функції, обєкти і т.д. Щоби вивести в консоль (звернутися до) apple.bmp, нам треба запрости 3 елемент масиву. Оскільки нумерація починється з нуля 0, то 
	третім тут буде №2 :
				console.log(arr[2]);
{прості типи даних - 1; 2; 3; 4; 5; 6; складні типи даних - спеціальні[7,1; function; обєкти дати; регулярні вираження; помилки] і звичайні [7] }    ^^^^^^^^^

alert("Hello World!");				виводить повідомлення в браузері. при цьому зупиняється весь скріпт, доки користувач не виконає дію.	

confirm("Are you here?");			виводить на екаран питання "ар ю гір?" з кнопками "ок" і "кансел". 

let answer = confirm("Are you here?");		якшо натиснемо "ок" - в консоль приїду булінгове занчення True
console.log(answer);				якшо "кансел"  - булінгове значення False

let answer = prompt("Есть ли вас 18?","DA");	з таким записом браузер буде видавати вікно з питанням, але користувач зможе написати довільну відповідь 
console.log(answer);				замість слова "ДА" (якшо залишити тільки кавички, до заготовленого слова не появиться). При цьому будь-яка
						відповідь від користувача буде в консолі показуватися типом даних "строка" стрінг, навіть, якшо ми вписуєм цифри. 
						Для того, щоби перевірити це, можна записати в коді так:
								let answer = prompt("Есть ли вас 18?","DA");
								console.log(typeof(answer));

typeof(answer);					команда дозволяє перевірити змінну на тип даних і викинадє інфу в консоль
isNaN(money);					команда провіряє змінну на тип число. Якшо змінна money містить тілки число, то 
								jscript видатьсь true, якшо в змінній числа не буде, то видасть false.
					*******Оператори*******
+	оператор додавання. Якшо число + число = число. строка + строка = строка. [число + строка = строка. (КОНКОТИНАЦІЯ)]. а ше + можна ставити перед командами і 
	він примусово поміняє тип даних з строки в число (його в таких пипадках називають унарним). наприклад:
							let answer = +prompt("Есть ли вас 18?","DA");
							console.log(typeof(answer));
інкремент ++	let incr = 10,
декремент --	decr = 10;
		incr++;
		decr--;

		console.log(incr);	(тут змінна інкр набуде занчення 9)
		console.log(decr);	(а тут змінна декр буде 11)


чим відрізняється префіксна форма від постфіксної? - Прекіксна змінює вже змінене значення, а постфіксна - старе.
		let incr = 10,
		    decr = 10;
		[[[[[[[[console.log(++incr);		а от в такому записі міначення поміняються, як 
		        console.log(--decr);]]]]]]]	і в попередньому випадку.
		[[[[[[[[console.log(incr++);		а от в такому записі значання не поміняються, 
		        console.log(decr--);]]]]]]]	оскільки їх це постфіксна форма.
%	оператор виводить остачу від ділення цілих чисел.
=	присвоєння (наприклад при змінних)
==	провірка на рівність. (строка "2" == число 2) - в консолі буде true, бо оператор == зрівнює значенння.
===	провірка по тимам даних. (строка "2" === число 2) - консолі буде False, бо оператор === зрівнює типи даних.
і &&	записується двома знаками імперсанта. 	true && true = true, true && false = false, false && false = false.
або ||	записується двома ||. 			true || true = true, true || false = true, false && false = false
!	оператор ! міняє правду в брехню і брехню в правду. його записують перед змінною

if	if (2*4 == 7) {console.log("Verno")} 	умова. так можна перевірити задану умову. Якшо провда - виконується перша стрічка.
	else {console.log("neverno")};		якшо неправда - друга стрічка. в даному випадку викунється друга стрічка.
						якшо після if не буде ніякого порівняння, а, наприклад, буде просто цифра 1, то відповідь
						завжди буде True

	логіку можна зобразити 4-ма різними записами:
1111111
let num = 50;

if (num < 49) {					if перевертає значення в дужках в логічний або булінговий бип диних
    console.log('neverno')
} else if (num > 100) {
    console.log('mnogo')
} else {
    console.log('verno')
};
2222222
// let num = 50;
(num == 50) ? console.log('verno') : console.log('neverno');	це скорочений запис. після знаку питання (інкремент) - якшо правда. після двокрапи (декримент) -
								неправда. є унарний(1), бінарний(2+2) і тернарний запис. це - тернарний (3 аргумента).

3333333
let num = 81;
switch (num) {					в дужках записуємо нашу умову, то, шо будемо перевіряти.
    case num < 49:				case тут замість if. 
        console.log('neverno!');
        break;					брейк ставиться для того, щоби розділити всі кейси і шоб прогряма не виконувала всьо підряд.
    case num > 100:
        console.log('mnogo!');
        break;
    case num > 80:
        console.log('vse shte mnogo');
        break;
    case 50:
        console.log('verno');
        break;
    default:
        console.log('chtoto poshlo ne tak');
        break;
}


	
			*******цикли********
*****
let num = 50;			такий запис актуальний, коли нам треба спочатку шось перевірити, а потім зробити
while (num < 55) {		поки НУМ залишається меншим 55 при збільшенні його кожного разу на 1
    console.log(num);		виводимо саме НУМ
    num++;			запис збільшення НУМ на 1
}

******
let num = 50;			такий запис корисний, коли нам спочатку треба шось зробити, а вже потім перевірити результат
do {				робити
    console.log(num);		таке то
    num++;
}
while (num < 55);		поки виконується умова
*******
for (let i = 1; i < 8; i++) {	відповідть в такому буде 1 2 3 4 5
    if (i == 6){		тут викорастили додаткову умову if, щоби зупинити оператор фор на значенні 6
        break;			зупияє оператор. цю функцію корисно застосовувати, коли є варіант зациклення до безкінечності
    }
    console.log(i);		виводить стільки числел і, скільки задовільнить умова
}

************
for (let i = 1; i < 8; i++) {	відповідь в такому буде 1 2 3 4 5 7.
    if (i == 6){
        continue;		ця команда дозволяє перескочити конкретні значення, не виконуючи ніяких дій з ними. корисно для вийнятків
    }
    console.log(i);
}
		********функції******
function ShowFirstMassage(text) {		імена для функцій записуються в форматі Camel Case. В круглих дужках записується
	alert(text);						параметри (їх може бути кілька). Коли ми запускаємо функцію, то заміть параметрів 
}										ми вводимо вже значення або змінні, з якими треба зробити певні дії, описані
										в даній функції. В фігурних дужках ми описуємо всі процеси, які повинні відбуватися
										в цій функції.
ShowFirstMassage('Hello World!');		так визиваэться вункція. 
										розрізняють експрешн та декалрейшн функції. На цьому прикладі представлений декалрейшн.
										експрешн - це коли зміннй присвоється функція. При токому випадку головною особливістю
										є те, що ця експрешн функція буде працювати тільки нижче того місця, де ми ЇЇ
										присвоїли. При декаларейнш типі цю функцію можна визвати в будь-якому місці коду.
let calc = (a,b) => {a+b};				це приклад стрілкової форми запису функції. Її використовують для економії коду.
console.log(calc (3,4));					Результатом буде 3+4=7
										розрізняють Declaration i Expression функції. 
*****Declaration****					такі функції можна визивати до обяви змінних, які фігурують в них.
function calc (a,b) {					їх можна стврювати до початку коду.
	return (a + b);
}
console.log(calc(3,4));					якщо цю строку перемістити вище самого декларування ф-ції, то дія все-рівно виконається.

     ******Expression****					Такі функції створюються тільки тоді, коли код до них доходить.				
let calc = function (a,b) {
	return (a + b);
}
console.log(calc(3,4));					при такій формі ця строка працюватиме тільки тоді, коли її записувати в коді після	
										запису самої ф-ції. Якшо записати її до, то консоль браузера викине помилку, накшталт
										"calc is not defined". 

	*****стрілкова форма функцій******	така форма використовується для опимізації коду (менше тексту). 
let calc = (a,b) => {a + b} 			треба знати, шо не в всіх випадках можна таку форму використовувати.
console.log(calc(3,4))					в токої форми нема свого контекста визова. її начастіше можна зустріти В
										оброботчиках собитий 

		*********методи в строк і чисел********
console.log(str.toUpperCase());			методи - це допоміжні функції. ВОни можуть міняти значення і, навідміну від
										властивостей, записуються з допоміжними дужками. Даний метод перетвоює всі букви в 
										великі.
console.log(str.toLowerCase());			перетворює букви в маленькі.

let twelve = "12.2";
console.log(Math.round(twelve));		значення змінної округлиться до цілих чисел
let twelve = "12.2";

console.log(parceInt(twelve));			приведе до числа 12
console.log(parceFloat(twelve));		приведе до числа з десятими = 12.2
console.log(money.toFixed(1 або 0))		метод поміняє змінну на строкову і призначений для округлення чисел.
										якшо в дужках буде пусто (0 наприклад), то метод округлить до цілих.
										якшо поставити 1, то будуть десяті і так далі.

		*********властивості в строк і чисел*********
let str = 'test';						властивості - це допоміжні значення. змінна + крапка + імя властивості.
										властивості не міняють значень. Вони просто виводить якіть їх характеристики.
console.log(str.length);				дана властивість порахує кількість знаків в строці.

		*********callback функції**********
function first(){						дана функція буде виконана з затримкою в пів секунди (500)
    //что-то делаем
    setTimeout (function()){
        console.log(1);
    }, 500);
}
function second(){						це ф-ція має вивести в консоль цифру 2
    console.log(2);
}

first();								у звязку з затримкою в перший ф-ції в консоль буде 
second();								виведена спочатку 2, а вже після 1